use super::DirectoryAnalyzer;
use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    ffi::OsStr,
    marker::Sized,
    path::{Path, PathBuf},
};
use walkdir::WalkDir;

/// `DistDirContainer` is a structure that holds the analyzing results for the `dist/` directory.
/// It contains a `HashMap` where the keys are page names (directories) and the values are `PageEntry` structures.
///
/// # Example
///
/// ```no_run
/// use metassr_fs_analyzer::dist_dir::{DistDirContainer, PageEntry};
/// use std::{collections::HashMap, path::PathBuf};
///
/// let mut container = DistDirContainer {
///     pages: HashMap::new(),
/// };
///
/// let page_entry = PageEntry::new(PathBuf::from("/dist/pages/home.js"));
/// container.pages.insert("home".to_string(), page_entry);
///
/// println!("{:?}", container.pages.get("home"));
/// ```
#[derive(Debug)]
pub struct DistDirContainer {
    pub pages: HashMap<String, PageEntry>, // Maps page paths to page entries
}

/// `PageEntry` represents the details for each page found in the `dist/` directory.
/// It includes the paths for JavaScript and CSS files (scripts and styles).
///
/// # Example
///
/// ```no_run
/// use metassr_fs_analyzer::dist_dir::PageEntry;
/// use std::path::PathBuf;
///
/// let mut page_entry = PageEntry::new(PathBuf::from("/dist/pages/home"));
///
/// page_entry.push_script(&PathBuf::from("/dist/pages/home/main.js"));
/// page_entry.push_style(&PathBuf::from("/dist/pages/home/main.css"));
///
/// println!("{:?}", page_entry);
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageEntry {
    pub scripts: Vec<PathBuf>, // List of paths to JavaScript files for the page
    pub styles: Vec<PathBuf>,  // List of paths to CSS files for the page
    pub path: PathBuf,         // The actual path of the page (directory)
}

impl PageEntry {
    /// Creates a new `PageEntry` given the path to a page.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use metassr_fs_analyzer::dist_dir::PageEntry;
    /// use std::path::PathBuf;
    /// 
    /// let page_entry = PageEntry::new(PathBuf::from("/dist/pages/home"));
    /// println!("{:?}", page_entry.path);
    /// ```
    pub fn new(path: PathBuf) -> Self {
        Self {
            scripts: vec![], // Initialize with an empty list of scripts
            styles: vec![],  // Initialize with an empty list of styles
            path,            // Set the path of the page
        }
    }

    /// Adds a script (JavaScript file) to the `scripts` list for the page.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use metassr_fs_analyzer::dist_dir::PageEntry;
    /// use std::path::PathBuf;
    ///
    /// let mut page_entry = PageEntry::new(PathBuf::from("/dist/pages/home"));
    /// page_entry.push_script(&PathBuf::from("/dist/pages/home/main.js"));
    /// println!("{:?}", page_entry.scripts);
    /// ```
    pub fn push_script(&mut self, path: &Path) {
        self.scripts.push(path.to_path_buf());
    }

    /// Adds a style (CSS file) to the `styles` list for the page.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use metassr_fs_analyzer::dist_dir::PageEntry;
    /// use std::path::PathBuf;
    ///
    /// let mut page_entry = PageEntry::new(PathBuf::from("/dist/pages/home"));
    /// page_entry.push_style(&PathBuf::from("/dist/pages/home/style.css"));
    /// println!("{:?}", page_entry.styles);
    /// ```
    pub fn push_style(&mut self, path: &Path) {
        self.styles.push(path.to_path_buf());
    }
}

/// `DistDir` is responsible for analyzing the `dist/` directory,
/// which is typically a folder generated by a bundler like `rspack` that contains JavaScript and CSS files.
/// It extracts and organizes the page structure based on the files inside the directory.
///
/// # Example
///
/// ```no_run
/// use metassr_fs_analyzer::{dist_dir::DistDir, DirectoryAnalyzer};
///
/// let dist_dir = DistDir::new("path/to/dist").unwrap();
/// let analysis_result = dist_dir.analyze().unwrap();
///
/// for (page, entry) in analysis_result.pages {
///     println!("Page: {}, Scripts: {:?}, Styles: {:?}", page, entry.scripts, entry.styles);
/// }
/// ```
#[derive(Debug)]
pub struct DistDir(PathBuf); // Contains the path to the `dist/` directory

impl DistDir {
    /// Creates a new `DistDir` struct given a path to the `dist/` directory.
    /// Returns an error if the provided path does not exist.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use metassr_fs_analyzer::dist_dir::DistDir;
    ///
    /// let dist_dir = DistDir::new("path/to/dist");
    /// match dist_dir {
    ///     Ok(dir) => println!("Dist directory found!"),
    ///     Err(e) => println!("Error: {}", e),
    /// }
    /// ```
    pub fn new<S>(path: &S) -> Result<Self>
    where
        S: AsRef<OsStr> + ?Sized, // Accepts types that can be referenced as `OsStr`
    {
        let path = PathBuf::from(path);

        // Check if the path exists, and return an error if not foundd
        if !path.exists() {
            return Err(anyhow!("Dist directory not found: {path:#?}"));
        }

        Ok(Self(path))
    }
}

/// `AnalyzeDir` trait is implemented for `DistDir`.
/// This implementation allows analyzing the directory and extracting its structure.
///
/// # Example
///
/// ```no_run
/// use metassr_fs_analyzer::{dist_dir::DistDir, DirectoryAnalyzer};
/// 
/// let dist_dir = DistDir::new("/path/to/dist").unwrap();
/// let result = dist_dir.analyze().unwrap();
/// for (page, entry) in result.pages {
///     println!("Page: {}, Scripts: {:?}, Styles: {:?}", page, entry.scripts, entry.styles);
/// }
/// ```
impl DirectoryAnalyzer for DistDir {
    type Output = DistDirContainer; // The output of the analysis is a `DistDirContainer`

    /// Analyzes the `dist/` directory to find and organize JavaScript and CSS files
    /// inside the `pages/` subdirectory, if it exists.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use metassr_fs_analyzer::{dist_dir::DistDir, DirectoryAnalyzer};
    ///
    /// let dist_dir = DistDir::new("path/to/dist").unwrap();
    /// let analysis_result = dist_dir.analyze().unwrap();
    ///
    /// for (page, entry) in analysis_result.pages {
    ///     println!("Page: {}, Scripts: {:?}, Styles: {:?}", page, entry.scripts, entry.styles);
    /// }
    /// ```
    fn analyze(&self) -> Result<Self::Output> {
        let pages_path = self.0.join("pages"); // Define the path to the `pages` directory inside `dist`
        let mut pages: HashMap<String, PageEntry> = HashMap::new(); // Create a `HashMap` to store pages

        // Traverse the `pages` directory recursively and filter out files based on extensions (js, css)
        for entry in WalkDir::new(pages_path.clone())
            .into_iter()
            .filter_map(|e| {
                let exts = ["js", "css"];
                match e.ok() {
                    Some(e)
                        if e.path().is_file()
                            && exts.contains(&e.path().extension().unwrap().to_str().unwrap()) =>
                    {
                        Some(e) // Include files that are either JS or CSS
                    }
                    _ => None,
                }
            })
        {
            let path = entry.path(); // Get the path of the current file
            let parent = path.parent().unwrap(); // Get the parent directory of the file (the page directory)

            // Strip the `pages_path` prefix from the parent directory path to get a relative path
            let parent_stripped = match parent.strip_prefix(pages_path.clone()).unwrap() {
                p if p == Path::new("") => "#root", // If no parent, set the root identifier
                p => p.to_str().unwrap(), // Otherwise, use the relative path as the identifier
            };

            let ext = path.extension().unwrap().to_str().unwrap(); // Get the file extension (js or css)

            // If the page does not already exist in the `pages` map, insert a new `PageEntry`
            if !pages.contains_key(parent_stripped) {
                pages.insert(
                    parent_stripped.to_owned(),
                    PageEntry::new(parent.to_path_buf().canonicalize().unwrap()), // Add canonicalized parent path
                );
            };

            let page_entry = pages.get_mut(parent_stripped).unwrap(); // Get the `PageEntry` for the current page

            // Depending on the file extension, add the file to either `scripts` or `styles`
            match ext {
                "js" => (*page_entry).push_script(path),
                "css" => (*page_entry).push_style(path),
                _ => (),
            }
        }

        // Return the analyzed pages in a `DistDirContainer`
        Ok(Self::Output { pages })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use metassr_utils::rand::Rand;
    use std::fs;
    /// Helper function to create a temporary directory structure for testing
    fn setup_test_dist_dir() -> PathBuf {
        let tmp_dir = std::env::temp_dir()
            .join(&Rand::new().val().to_string())
            .join("test-dist");
        let pages_dir = tmp_dir.join("pages");

        // Clear any previous test data
        if pages_dir.exists() {
            fs::remove_dir_all(&pages_dir).unwrap();
        }

        fs::create_dir_all(&pages_dir).unwrap();

        // Create some test files
        fs::write(pages_dir.join("index.js"), "// JavaScript file").unwrap();
        fs::write(pages_dir.join("style.css"), "/* CSS file */").unwrap();
        fs::create_dir(pages_dir.join("subdir")).unwrap();
        fs::write(
            pages_dir.join("subdir").join("script.js"),
            "// Subdir JS file",
        )
        .unwrap();
        fs::write(
            pages_dir.join("subdir").join("substyle.css"),
            "/* Subdir CSS file */",
        )
        .unwrap();
        dbg!(&tmp_dir.canonicalize(), &pages_dir.canonicalize());
        tmp_dir
    }

    /// Clean up the test directory after tests
    fn cleanup_test_dist_dir(test_dir: PathBuf) {
        if test_dir.exists() {
            fs::remove_dir_all(test_dir).unwrap();
        }
    }

    #[test]
    fn test_analyze_valid_dist_dir() {
        let test_dir = setup_test_dist_dir();
        let dist_dir = DistDir::new(&test_dir).unwrap();

        let result = dist_dir.analyze().unwrap();
        let pages = result.pages;

        // Ensure correct number of pages
        assert_eq!(
            pages.len(),
            2,
            "Expected 2 page entries, found {}",
            pages.len()
        );

        // Validate root page
        let root_page = pages.get("#root").expect("Root page should exist");
        assert_eq!(root_page.scripts.len(), 1, "Expected 1 script in root page");
        assert_eq!(root_page.styles.len(), 1, "Expected 1 style in root page");

        // Validate subdir page
        let subdir_page = pages.get("subdir").expect("Subdir page should exist");
        assert_eq!(
            subdir_page.scripts.len(),
            1,
            "Expected 1 script in subdir page"
        );
        assert_eq!(
            subdir_page.styles.len(),
            1,
            "Expected 1 style in subdir page"
        );

        cleanup_test_dist_dir(test_dir);
    }

    #[test]
    fn test_dist_dir_not_found() {
        let invalid_path = std::env::temp_dir().join("invalid-dist");
        let result = DistDir::new(&invalid_path);

        assert!(
            result.is_err(),
            "Expected error when dist directory is not found"
        );
        if let Err(err) = result {
            assert!(
                err.to_string().contains("Dist directory not found"),
                "Unexpected error message: {}",
                err
            );
        }
    }

    #[test]
    fn test_empty_dist_dir() {
        let test_dir = std::env::temp_dir().join("empty-test-dist");
        fs::create_dir_all(test_dir.join("pages")).unwrap(); // Create empty pages directory

        let dist_dir = DistDir::new(&test_dir).unwrap();
        let result = dist_dir.analyze().unwrap();

        assert!(
            result.pages.is_empty(),
            "Expected no page entries in an empty dist directory"
        );

        cleanup_test_dist_dir(test_dir);
    }

    #[test]
    fn test_analyze_unsupported_file_extensions() {
        let test_dir = setup_test_dist_dir();

        // Create a file with an unsupported extension
        fs::write(
            test_dir.join("pages").join("unsupported.txt"),
            "Unsupported file",
        )
        .unwrap();

        let dist_dir = DistDir::new(&test_dir).unwrap();
        let result = dist_dir.analyze().unwrap();

        // Ensure the unsupported file is ignored
        assert_eq!(
            result.pages.len(),
            2,
            "Expected 2 page entries, found {}",
            result.pages.len()
        );

        cleanup_test_dist_dir(test_dir);
    }

    #[test]
    fn test_analyze_dist_dir_with_only_scripts() {
        let test_dir = std::env::temp_dir().join("script-only-test-dist");
        let pages_dir = test_dir.join("pages");

        fs::create_dir_all(&pages_dir).unwrap();
        fs::write(pages_dir.join("script.js"), "// JavaScript file").unwrap();

        let dist_dir = DistDir::new(&test_dir).unwrap();
        let result = dist_dir.analyze().unwrap();

        let root_page = result.pages.get("#root").expect("Root page should exist");
        assert_eq!(root_page.scripts.len(), 1, "Expected 1 script file");
        assert!(root_page.styles.is_empty(), "Expected no styles");

        cleanup_test_dist_dir(test_dir);
    }

    #[test]
    fn test_analyze_dist_dir_with_only_styles() {
        let test_dir = std::env::temp_dir().join("style-only-test-dist");
        let pages_dir = test_dir.join("pages");

        fs::create_dir_all(&pages_dir).unwrap();
        fs::write(pages_dir.join("style.css"), "/* CSS file */").unwrap();

        let dist_dir = DistDir::new(&test_dir).unwrap();
        let result = dist_dir.analyze().unwrap();

        let root_page = result.pages.get("#root").expect("Root page should exist");
        assert_eq!(root_page.styles.len(), 1, "Expected 1 style file");
        assert!(root_page.scripts.is_empty(), "Expected no scripts");

        cleanup_test_dist_dir(test_dir);
    }
}
